// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "session_resp.proto" (package "messages", syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message messages.SessionResponse
 */
export interface SessionResponse {
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "join";
        /**
         * @generated from protobuf field: messages.ResponseJoin join = 1
         */
        join: ResponseJoin;
    } | {
        oneofKind: "roomInfoChanged";
        /**
         * @generated from protobuf field: messages.ResponseRoomInfoChanged room_info_changed = 2
         */
        roomInfoChanged: ResponseRoomInfoChanged;
    } | {
        oneofKind: "stageChange";
        /**
         * @generated from protobuf field: messages.ResponseStageChange stage_change = 3
         */
        stageChange: ResponseStageChange;
    } | {
        oneofKind: "roomClosed";
        /**
         * @generated from protobuf field: messages.ResponseRoomClosed room_closed = 4
         */
        roomClosed: ResponseRoomClosed;
    } | {
        oneofKind: "readyCountUpdate";
        /**
         * @generated from protobuf field: messages.ResponseReadyCountUpdate ready_count_update = 5
         */
        readyCountUpdate: ResponseReadyCountUpdate;
    } | {
        oneofKind: "loadedCountUpdate";
        /**
         * @generated from protobuf field: messages.ResponseLoadedCountUpdate loaded_count_update = 6
         */
        loadedCountUpdate: ResponseLoadedCountUpdate;
    } | {
        oneofKind: "inGameFrames";
        /**
         * @generated from protobuf field: messages.ResponseInGameFrames in_game_frames = 7
         */
        inGameFrames: ResponseInGameFrames;
    } | {
        oneofKind: "endGame";
        /**
         * @generated from protobuf field: messages.ResponseEndGame end_game = 8
         */
        endGame: ResponseEndGame;
    } | {
        oneofKind: "other";
        /**
         * @generated from protobuf field: messages.ResponseOther other = 9
         */
        other: ResponseOther;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message messages.RoomInfo
 */
export interface RoomInfo {
    /**
     * @generated from protobuf field: string RoomKey = 2
     */
    roomKey: string;
    /**
     * @generated from protobuf field: int32 MaxPlayers = 4
     */
    maxPlayers: number;
    /**
     * @generated from protobuf field: int32 CurrentPlayers = 5
     */
    currentPlayers: number;
    /**
     * @generated from protobuf field: repeated uint32 PlayerIDs = 6
     */
    playerIDs: number[];
    /**
     * 附加数据
     *
     * @generated from protobuf field: optional bytes data = 7
     */
    data?: Uint8Array;
}
/**
 * @generated from protobuf message messages.ResponseJoinSuccess
 */
export interface ResponseJoinSuccess {
    /**
     * @generated from protobuf field: uint32 RoomID = 1
     */
    roomID: number;
    /**
     * @generated from protobuf field: messages.RoomInfo RoomInfo = 4
     */
    roomInfo?: RoomInfo;
    /**
     * @generated from protobuf field: uint32 MyID = 2
     */
    myID: number;
    /**
     * @generated from protobuf field: string ReconnectToken = 3
     */
    reconnectToken: string;
}
/**
 * @generated from protobuf message messages.ResponseJoinFail
 */
export interface ResponseJoinFail {
    /**
     * @generated from protobuf field: string Message = 1
     */
    message: string;
}
/**
 * @generated from protobuf message messages.ResponseJoin
 */
export interface ResponseJoin {
    /**
     * status code
     * 200 = success
     * 400 = fail
     *
     * @generated from protobuf field: uint32 code = 1
     */
    code: number;
    /**
     * @generated from protobuf oneof: payload
     */
    payload: {
        oneofKind: "success";
        /**
         * @generated from protobuf field: messages.ResponseJoinSuccess success = 2
         */
        success: ResponseJoinSuccess;
    } | {
        oneofKind: "fail";
        /**
         * @generated from protobuf field: messages.ResponseJoinFail fail = 3
         */
        fail: ResponseJoinFail;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message messages.ResponseRoomInfoChanged
 */
export interface ResponseRoomInfoChanged {
    /**
     * @generated from protobuf field: messages.RoomInfo room_info = 1
     */
    roomInfo?: RoomInfo;
}
/**
 * @generated from protobuf message messages.ResponseRoomClosed
 */
export interface ResponseRoomClosed {
    /**
     * @generated from protobuf field: string Reason = 1
     */
    reason: string;
}
/**
 * 通知客户端房间阶段变更
 * 响应体使用不同的NewStage字段而非不同的响应类型，以方便客户端分支处理
 *
 * @generated from protobuf message messages.ResponseStageChange
 */
export interface ResponseStageChange {
    /**
     * 新字段的常量
     * STAGE_InLobby   Stage = 0x20 // InLobby (房间.等待中): 房间刚被创建,所有人还在房间中，等待玩家加入，房主可以设置游戏。
     * STAGE_Preparing Stage = 0x21 // Preparing (房间.准备中): 房主已发起游戏，所有玩家选择装备并确认准备。
     * STAGE_Loading   Stage = 0x22 // Loading (游戏.加载中): 游戏开始前的加载阶段，所有玩家准备完毕后进入 InGame。
     * STAGE_InGame    Stage = 0x23 // InGame (游戏.游戏中): 所有玩家准备就绪，游戏正式开始，由定时器驱动逻辑。
     * STAGE_PostGame  Stage = 0x24 // PostGame (游戏.游戏后结算): 游戏结束，显示战绩，等待返回大厅。
     * STAGE_CLOSED Stage = 0xEE
     * STAGE_Error  Stage = 0xFF
     *
     * @generated from protobuf field: uint32 NewStage = 1
     */
    newStage: number;
    /**
     * 可以携带更多的数据
     * 本框架自身不用此字段
     *
     * @generated from protobuf field: optional bytes data = 2
     */
    data?: Uint8Array;
}
/**
 * 更新已经ready的人数
 *
 * @generated from protobuf message messages.ResponseReadyCountUpdate
 */
export interface ResponseReadyCountUpdate {
    /**
     * @generated from protobuf field: uint32 ready_count = 1
     */
    readyCount: number;
    /**
     * @generated from protobuf field: uint32 total_count = 2
     */
    totalCount: number;
}
/**
 * 更新已经loaded的人数
 *
 * @generated from protobuf message messages.ResponseLoadedCountUpdate
 */
export interface ResponseLoadedCountUpdate {
    /**
     * @generated from protobuf field: uint32 loaded_count = 1
     */
    loadedCount: number;
    /**
     * @generated from protobuf field: uint32 total_count = 2
     */
    totalCount: number;
}
/**
 * 用户的输入序列
 * 1. 影响权威游戏世界
 * 2. 直接进行帧同步广播
 *
 * @generated from protobuf message messages.ClientInputData
 */
export interface ClientInputData {
    /**
     * @generated from protobuf field: uint32 uid = 1
     */
    uid: number;
    /**
     * 用户发送数据时,其所在的FrameID
     * 游戏世界需要自行处理例如延迟补偿等机制
     *
     * e.g. Lag Compensation, Display of Targets
     *
     * @generated from protobuf field: uint32 frame_id = 2
     */
    frameId: number;
    /**
     * 解析后的框架无关的额外Bytes,不带有帧ID的原始输入队列
     * e.g. [{"method" : "move", "direction": "up"}]
     *
     * @generated from protobuf field: bytes data = 3
     */
    data: Uint8Array;
}
/**
 * 游戏事件
 *
 * @generated from protobuf message messages.WorldEventData
 */
export interface WorldEventData {
    /**
     * 事件对哪个帧号造成影响
     * 即事件后的下一帧
     *
     * @generated from protobuf field: uint32 frame_id = 1
     */
    frameId: number;
    /**
     * 事件的原始数据队列
     * e.g. [{"eventType": "explosion", "position": [100,200]}]
     *
     * 如果是超大地图需要分chunk的游戏，此data也推荐用于顺便携带某next帧的某chunk状态同步数据
     *
     * @generated from protobuf field: bytes data = 2
     */
    data: Uint8Array;
}
/**
 * 每一帧的完整数据包
 *
 * @generated from protobuf message messages.FrameData
 */
export interface FrameData {
    /**
     * 本次服务端将要步进到的帧 ID
     * FrameData和input, events都带有FrameID字段是为了延迟补偿
     * 告知客户端，之前的帧中有遗漏的操作和时间发生
     *
     * @generated from protobuf field: uint32 frame_id = 1
     */
    frameId: number;
    /**
     * 帧数据内容
     * ---
     * 包含了本帧所有用户的输入
     *
     * @generated from protobuf field: repeated messages.ClientInputData input_array = 2
     */
    inputArray: ClientInputData[];
    /**
     * 包含了本帧发生的所有游戏世界事件
     *
     * @generated from protobuf field: repeated messages.WorldEventData events = 3
     */
    events: WorldEventData[];
    /**
     * Checksum 的类型应为 uint64 以接收 xxh3.Sum64() 的结果
     *
     * @generated from protobuf field: uint64 checksum = 4
     */
    checksum: bigint;
}
/**
 * @generated from protobuf message messages.ResponseInGameFrames
 */
export interface ResponseInGameFrames {
    /**
     * @generated from protobuf field: repeated messages.FrameData frames = 1
     */
    frames: FrameData[];
}
/**
 * @generated from protobuf message messages.ResponseEndGame
 */
export interface ResponseEndGame {
    /**
     * 游戏结束状态码
     *
     * @generated from protobuf field: uint32 StatusCode = 1
     */
    statusCode: number;
    /**
     * 携带的bytes，框架将直接传给游戏世界处理
     *
     * @generated from protobuf field: optional bytes data = 2
     */
    data?: Uint8Array;
}
/**
 * 其他响应
 * 例如聊天信息等不重要的
 *
 * @generated from protobuf message messages.ResponseOther
 */
export interface ResponseOther {
    /**
     * 可以携带更多的数据
     * 本框架自身不用此字段
     *
     * @generated from protobuf field: optional bytes data = 1
     */
    data?: Uint8Array;
}
// @generated message type with reflection information, may provide speed optimized methods
class SessionResponse$Type extends MessageType<SessionResponse> {
    constructor() {
        super("messages.SessionResponse", [
            { no: 1, name: "join", kind: "message", oneof: "payload", T: () => ResponseJoin },
            { no: 2, name: "room_info_changed", kind: "message", oneof: "payload", T: () => ResponseRoomInfoChanged },
            { no: 3, name: "stage_change", kind: "message", oneof: "payload", T: () => ResponseStageChange },
            { no: 4, name: "room_closed", kind: "message", oneof: "payload", T: () => ResponseRoomClosed },
            { no: 5, name: "ready_count_update", kind: "message", oneof: "payload", T: () => ResponseReadyCountUpdate },
            { no: 6, name: "loaded_count_update", kind: "message", oneof: "payload", T: () => ResponseLoadedCountUpdate },
            { no: 7, name: "in_game_frames", kind: "message", oneof: "payload", T: () => ResponseInGameFrames },
            { no: 8, name: "end_game", kind: "message", oneof: "payload", T: () => ResponseEndGame },
            { no: 9, name: "other", kind: "message", oneof: "payload", T: () => ResponseOther }
        ]);
    }
    create(value?: PartialMessage<SessionResponse>): SessionResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<SessionResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SessionResponse): SessionResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* messages.ResponseJoin join */ 1:
                    message.payload = {
                        oneofKind: "join",
                        join: ResponseJoin.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).join)
                    };
                    break;
                case /* messages.ResponseRoomInfoChanged room_info_changed */ 2:
                    message.payload = {
                        oneofKind: "roomInfoChanged",
                        roomInfoChanged: ResponseRoomInfoChanged.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).roomInfoChanged)
                    };
                    break;
                case /* messages.ResponseStageChange stage_change */ 3:
                    message.payload = {
                        oneofKind: "stageChange",
                        stageChange: ResponseStageChange.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).stageChange)
                    };
                    break;
                case /* messages.ResponseRoomClosed room_closed */ 4:
                    message.payload = {
                        oneofKind: "roomClosed",
                        roomClosed: ResponseRoomClosed.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).roomClosed)
                    };
                    break;
                case /* messages.ResponseReadyCountUpdate ready_count_update */ 5:
                    message.payload = {
                        oneofKind: "readyCountUpdate",
                        readyCountUpdate: ResponseReadyCountUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).readyCountUpdate)
                    };
                    break;
                case /* messages.ResponseLoadedCountUpdate loaded_count_update */ 6:
                    message.payload = {
                        oneofKind: "loadedCountUpdate",
                        loadedCountUpdate: ResponseLoadedCountUpdate.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).loadedCountUpdate)
                    };
                    break;
                case /* messages.ResponseInGameFrames in_game_frames */ 7:
                    message.payload = {
                        oneofKind: "inGameFrames",
                        inGameFrames: ResponseInGameFrames.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).inGameFrames)
                    };
                    break;
                case /* messages.ResponseEndGame end_game */ 8:
                    message.payload = {
                        oneofKind: "endGame",
                        endGame: ResponseEndGame.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).endGame)
                    };
                    break;
                case /* messages.ResponseOther other */ 9:
                    message.payload = {
                        oneofKind: "other",
                        other: ResponseOther.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).other)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SessionResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* messages.ResponseJoin join = 1; */
        if (message.payload.oneofKind === "join")
            ResponseJoin.internalBinaryWrite(message.payload.join, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseRoomInfoChanged room_info_changed = 2; */
        if (message.payload.oneofKind === "roomInfoChanged")
            ResponseRoomInfoChanged.internalBinaryWrite(message.payload.roomInfoChanged, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseStageChange stage_change = 3; */
        if (message.payload.oneofKind === "stageChange")
            ResponseStageChange.internalBinaryWrite(message.payload.stageChange, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseRoomClosed room_closed = 4; */
        if (message.payload.oneofKind === "roomClosed")
            ResponseRoomClosed.internalBinaryWrite(message.payload.roomClosed, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseReadyCountUpdate ready_count_update = 5; */
        if (message.payload.oneofKind === "readyCountUpdate")
            ResponseReadyCountUpdate.internalBinaryWrite(message.payload.readyCountUpdate, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseLoadedCountUpdate loaded_count_update = 6; */
        if (message.payload.oneofKind === "loadedCountUpdate")
            ResponseLoadedCountUpdate.internalBinaryWrite(message.payload.loadedCountUpdate, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseInGameFrames in_game_frames = 7; */
        if (message.payload.oneofKind === "inGameFrames")
            ResponseInGameFrames.internalBinaryWrite(message.payload.inGameFrames, writer.tag(7, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseEndGame end_game = 8; */
        if (message.payload.oneofKind === "endGame")
            ResponseEndGame.internalBinaryWrite(message.payload.endGame, writer.tag(8, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseOther other = 9; */
        if (message.payload.oneofKind === "other")
            ResponseOther.internalBinaryWrite(message.payload.other, writer.tag(9, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.SessionResponse
 */
export const SessionResponse = new SessionResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class RoomInfo$Type extends MessageType<RoomInfo> {
    constructor() {
        super("messages.RoomInfo", [
            { no: 2, name: "RoomKey", kind: "scalar", jsonName: "RoomKey", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "MaxPlayers", kind: "scalar", jsonName: "MaxPlayers", T: 5 /*ScalarType.INT32*/ },
            { no: 5, name: "CurrentPlayers", kind: "scalar", jsonName: "CurrentPlayers", T: 5 /*ScalarType.INT32*/ },
            { no: 6, name: "PlayerIDs", kind: "scalar", jsonName: "PlayerIDs", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ },
            { no: 7, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<RoomInfo>): RoomInfo {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roomKey = "";
        message.maxPlayers = 0;
        message.currentPlayers = 0;
        message.playerIDs = [];
        if (value !== undefined)
            reflectionMergePartial<RoomInfo>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: RoomInfo): RoomInfo {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string RoomKey */ 2:
                    message.roomKey = reader.string();
                    break;
                case /* int32 MaxPlayers */ 4:
                    message.maxPlayers = reader.int32();
                    break;
                case /* int32 CurrentPlayers */ 5:
                    message.currentPlayers = reader.int32();
                    break;
                case /* repeated uint32 PlayerIDs */ 6:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.playerIDs.push(reader.uint32());
                    else
                        message.playerIDs.push(reader.uint32());
                    break;
                case /* optional bytes data */ 7:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: RoomInfo, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string RoomKey = 2; */
        if (message.roomKey !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.roomKey);
        /* int32 MaxPlayers = 4; */
        if (message.maxPlayers !== 0)
            writer.tag(4, WireType.Varint).int32(message.maxPlayers);
        /* int32 CurrentPlayers = 5; */
        if (message.currentPlayers !== 0)
            writer.tag(5, WireType.Varint).int32(message.currentPlayers);
        /* repeated uint32 PlayerIDs = 6; */
        if (message.playerIDs.length) {
            writer.tag(6, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.playerIDs.length; i++)
                writer.uint32(message.playerIDs[i]);
            writer.join();
        }
        /* optional bytes data = 7; */
        if (message.data !== undefined)
            writer.tag(7, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.RoomInfo
 */
export const RoomInfo = new RoomInfo$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseJoinSuccess$Type extends MessageType<ResponseJoinSuccess> {
    constructor() {
        super("messages.ResponseJoinSuccess", [
            { no: 1, name: "RoomID", kind: "scalar", jsonName: "RoomID", T: 13 /*ScalarType.UINT32*/ },
            { no: 4, name: "RoomInfo", kind: "message", jsonName: "RoomInfo", T: () => RoomInfo },
            { no: 2, name: "MyID", kind: "scalar", jsonName: "MyID", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "ReconnectToken", kind: "scalar", jsonName: "ReconnectToken", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseJoinSuccess>): ResponseJoinSuccess {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roomID = 0;
        message.myID = 0;
        message.reconnectToken = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseJoinSuccess>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseJoinSuccess): ResponseJoinSuccess {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 RoomID */ 1:
                    message.roomID = reader.uint32();
                    break;
                case /* messages.RoomInfo RoomInfo */ 4:
                    message.roomInfo = RoomInfo.internalBinaryRead(reader, reader.uint32(), options, message.roomInfo);
                    break;
                case /* uint32 MyID */ 2:
                    message.myID = reader.uint32();
                    break;
                case /* string ReconnectToken */ 3:
                    message.reconnectToken = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseJoinSuccess, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 RoomID = 1; */
        if (message.roomID !== 0)
            writer.tag(1, WireType.Varint).uint32(message.roomID);
        /* uint32 MyID = 2; */
        if (message.myID !== 0)
            writer.tag(2, WireType.Varint).uint32(message.myID);
        /* string ReconnectToken = 3; */
        if (message.reconnectToken !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.reconnectToken);
        /* messages.RoomInfo RoomInfo = 4; */
        if (message.roomInfo)
            RoomInfo.internalBinaryWrite(message.roomInfo, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseJoinSuccess
 */
export const ResponseJoinSuccess = new ResponseJoinSuccess$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseJoinFail$Type extends MessageType<ResponseJoinFail> {
    constructor() {
        super("messages.ResponseJoinFail", [
            { no: 1, name: "Message", kind: "scalar", jsonName: "Message", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseJoinFail>): ResponseJoinFail {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseJoinFail>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseJoinFail): ResponseJoinFail {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseJoinFail, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseJoinFail
 */
export const ResponseJoinFail = new ResponseJoinFail$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseJoin$Type extends MessageType<ResponseJoin> {
    constructor() {
        super("messages.ResponseJoin", [
            { no: 1, name: "code", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "success", kind: "message", oneof: "payload", T: () => ResponseJoinSuccess },
            { no: 3, name: "fail", kind: "message", oneof: "payload", T: () => ResponseJoinFail }
        ]);
    }
    create(value?: PartialMessage<ResponseJoin>): ResponseJoin {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.code = 0;
        message.payload = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<ResponseJoin>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseJoin): ResponseJoin {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 code */ 1:
                    message.code = reader.uint32();
                    break;
                case /* messages.ResponseJoinSuccess success */ 2:
                    message.payload = {
                        oneofKind: "success",
                        success: ResponseJoinSuccess.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).success)
                    };
                    break;
                case /* messages.ResponseJoinFail fail */ 3:
                    message.payload = {
                        oneofKind: "fail",
                        fail: ResponseJoinFail.internalBinaryRead(reader, reader.uint32(), options, (message.payload as any).fail)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseJoin, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 code = 1; */
        if (message.code !== 0)
            writer.tag(1, WireType.Varint).uint32(message.code);
        /* messages.ResponseJoinSuccess success = 2; */
        if (message.payload.oneofKind === "success")
            ResponseJoinSuccess.internalBinaryWrite(message.payload.success, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* messages.ResponseJoinFail fail = 3; */
        if (message.payload.oneofKind === "fail")
            ResponseJoinFail.internalBinaryWrite(message.payload.fail, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseJoin
 */
export const ResponseJoin = new ResponseJoin$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseRoomInfoChanged$Type extends MessageType<ResponseRoomInfoChanged> {
    constructor() {
        super("messages.ResponseRoomInfoChanged", [
            { no: 1, name: "room_info", kind: "message", T: () => RoomInfo }
        ]);
    }
    create(value?: PartialMessage<ResponseRoomInfoChanged>): ResponseRoomInfoChanged {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResponseRoomInfoChanged>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseRoomInfoChanged): ResponseRoomInfoChanged {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* messages.RoomInfo room_info */ 1:
                    message.roomInfo = RoomInfo.internalBinaryRead(reader, reader.uint32(), options, message.roomInfo);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseRoomInfoChanged, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* messages.RoomInfo room_info = 1; */
        if (message.roomInfo)
            RoomInfo.internalBinaryWrite(message.roomInfo, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseRoomInfoChanged
 */
export const ResponseRoomInfoChanged = new ResponseRoomInfoChanged$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseRoomClosed$Type extends MessageType<ResponseRoomClosed> {
    constructor() {
        super("messages.ResponseRoomClosed", [
            { no: 1, name: "Reason", kind: "scalar", jsonName: "Reason", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseRoomClosed>): ResponseRoomClosed {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.reason = "";
        if (value !== undefined)
            reflectionMergePartial<ResponseRoomClosed>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseRoomClosed): ResponseRoomClosed {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string Reason */ 1:
                    message.reason = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseRoomClosed, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string Reason = 1; */
        if (message.reason !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.reason);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseRoomClosed
 */
export const ResponseRoomClosed = new ResponseRoomClosed$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseStageChange$Type extends MessageType<ResponseStageChange> {
    constructor() {
        super("messages.ResponseStageChange", [
            { no: 1, name: "NewStage", kind: "scalar", jsonName: "NewStage", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseStageChange>): ResponseStageChange {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.newStage = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseStageChange>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseStageChange): ResponseStageChange {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 NewStage */ 1:
                    message.newStage = reader.uint32();
                    break;
                case /* optional bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseStageChange, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 NewStage = 1; */
        if (message.newStage !== 0)
            writer.tag(1, WireType.Varint).uint32(message.newStage);
        /* optional bytes data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseStageChange
 */
export const ResponseStageChange = new ResponseStageChange$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseReadyCountUpdate$Type extends MessageType<ResponseReadyCountUpdate> {
    constructor() {
        super("messages.ResponseReadyCountUpdate", [
            { no: 1, name: "ready_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "total_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseReadyCountUpdate>): ResponseReadyCountUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.readyCount = 0;
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseReadyCountUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseReadyCountUpdate): ResponseReadyCountUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 ready_count */ 1:
                    message.readyCount = reader.uint32();
                    break;
                case /* uint32 total_count */ 2:
                    message.totalCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseReadyCountUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 ready_count = 1; */
        if (message.readyCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.readyCount);
        /* uint32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseReadyCountUpdate
 */
export const ResponseReadyCountUpdate = new ResponseReadyCountUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseLoadedCountUpdate$Type extends MessageType<ResponseLoadedCountUpdate> {
    constructor() {
        super("messages.ResponseLoadedCountUpdate", [
            { no: 1, name: "loaded_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "total_count", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseLoadedCountUpdate>): ResponseLoadedCountUpdate {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.loadedCount = 0;
        message.totalCount = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseLoadedCountUpdate>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseLoadedCountUpdate): ResponseLoadedCountUpdate {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 loaded_count */ 1:
                    message.loadedCount = reader.uint32();
                    break;
                case /* uint32 total_count */ 2:
                    message.totalCount = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseLoadedCountUpdate, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 loaded_count = 1; */
        if (message.loadedCount !== 0)
            writer.tag(1, WireType.Varint).uint32(message.loadedCount);
        /* uint32 total_count = 2; */
        if (message.totalCount !== 0)
            writer.tag(2, WireType.Varint).uint32(message.totalCount);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseLoadedCountUpdate
 */
export const ResponseLoadedCountUpdate = new ResponseLoadedCountUpdate$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ClientInputData$Type extends MessageType<ClientInputData> {
    constructor() {
        super("messages.ClientInputData", [
            { no: 1, name: "uid", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "frame_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 3, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ClientInputData>): ClientInputData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.uid = 0;
        message.frameId = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<ClientInputData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ClientInputData): ClientInputData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 uid */ 1:
                    message.uid = reader.uint32();
                    break;
                case /* uint32 frame_id */ 2:
                    message.frameId = reader.uint32();
                    break;
                case /* bytes data */ 3:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ClientInputData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 uid = 1; */
        if (message.uid !== 0)
            writer.tag(1, WireType.Varint).uint32(message.uid);
        /* uint32 frame_id = 2; */
        if (message.frameId !== 0)
            writer.tag(2, WireType.Varint).uint32(message.frameId);
        /* bytes data = 3; */
        if (message.data.length)
            writer.tag(3, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ClientInputData
 */
export const ClientInputData = new ClientInputData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class WorldEventData$Type extends MessageType<WorldEventData> {
    constructor() {
        super("messages.WorldEventData", [
            { no: 1, name: "frame_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<WorldEventData>): WorldEventData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frameId = 0;
        message.data = new Uint8Array(0);
        if (value !== undefined)
            reflectionMergePartial<WorldEventData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: WorldEventData): WorldEventData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 frame_id */ 1:
                    message.frameId = reader.uint32();
                    break;
                case /* bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: WorldEventData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 frame_id = 1; */
        if (message.frameId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.frameId);
        /* bytes data = 2; */
        if (message.data.length)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.WorldEventData
 */
export const WorldEventData = new WorldEventData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FrameData$Type extends MessageType<FrameData> {
    constructor() {
        super("messages.FrameData", [
            { no: 1, name: "frame_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "input_array", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => ClientInputData },
            { no: 3, name: "events", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => WorldEventData },
            { no: 4, name: "checksum", kind: "scalar", T: 4 /*ScalarType.UINT64*/, L: 0 /*LongType.BIGINT*/ }
        ]);
    }
    create(value?: PartialMessage<FrameData>): FrameData {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frameId = 0;
        message.inputArray = [];
        message.events = [];
        message.checksum = 0n;
        if (value !== undefined)
            reflectionMergePartial<FrameData>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FrameData): FrameData {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 frame_id */ 1:
                    message.frameId = reader.uint32();
                    break;
                case /* repeated messages.ClientInputData input_array */ 2:
                    message.inputArray.push(ClientInputData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* repeated messages.WorldEventData events */ 3:
                    message.events.push(WorldEventData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                case /* uint64 checksum */ 4:
                    message.checksum = reader.uint64().toBigInt();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FrameData, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 frame_id = 1; */
        if (message.frameId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.frameId);
        /* repeated messages.ClientInputData input_array = 2; */
        for (let i = 0; i < message.inputArray.length; i++)
            ClientInputData.internalBinaryWrite(message.inputArray[i], writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* repeated messages.WorldEventData events = 3; */
        for (let i = 0; i < message.events.length; i++)
            WorldEventData.internalBinaryWrite(message.events[i], writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* uint64 checksum = 4; */
        if (message.checksum !== 0n)
            writer.tag(4, WireType.Varint).uint64(message.checksum);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.FrameData
 */
export const FrameData = new FrameData$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseInGameFrames$Type extends MessageType<ResponseInGameFrames> {
    constructor() {
        super("messages.ResponseInGameFrames", [
            { no: 1, name: "frames", kind: "message", repeat: 2 /*RepeatType.UNPACKED*/, T: () => FrameData }
        ]);
    }
    create(value?: PartialMessage<ResponseInGameFrames>): ResponseInGameFrames {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.frames = [];
        if (value !== undefined)
            reflectionMergePartial<ResponseInGameFrames>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseInGameFrames): ResponseInGameFrames {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated messages.FrameData frames */ 1:
                    message.frames.push(FrameData.internalBinaryRead(reader, reader.uint32(), options));
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseInGameFrames, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated messages.FrameData frames = 1; */
        for (let i = 0; i < message.frames.length; i++)
            FrameData.internalBinaryWrite(message.frames[i], writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseInGameFrames
 */
export const ResponseInGameFrames = new ResponseInGameFrames$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseEndGame$Type extends MessageType<ResponseEndGame> {
    constructor() {
        super("messages.ResponseEndGame", [
            { no: 1, name: "StatusCode", kind: "scalar", jsonName: "StatusCode", T: 13 /*ScalarType.UINT32*/ },
            { no: 2, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseEndGame>): ResponseEndGame {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.statusCode = 0;
        if (value !== undefined)
            reflectionMergePartial<ResponseEndGame>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseEndGame): ResponseEndGame {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 StatusCode */ 1:
                    message.statusCode = reader.uint32();
                    break;
                case /* optional bytes data */ 2:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseEndGame, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 StatusCode = 1; */
        if (message.statusCode !== 0)
            writer.tag(1, WireType.Varint).uint32(message.statusCode);
        /* optional bytes data = 2; */
        if (message.data !== undefined)
            writer.tag(2, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseEndGame
 */
export const ResponseEndGame = new ResponseEndGame$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ResponseOther$Type extends MessageType<ResponseOther> {
    constructor() {
        super("messages.ResponseOther", [
            { no: 1, name: "data", kind: "scalar", opt: true, T: 12 /*ScalarType.BYTES*/ }
        ]);
    }
    create(value?: PartialMessage<ResponseOther>): ResponseOther {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ResponseOther>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ResponseOther): ResponseOther {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* optional bytes data */ 1:
                    message.data = reader.bytes();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ResponseOther, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* optional bytes data = 1; */
        if (message.data !== undefined)
            writer.tag(1, WireType.LengthDelimited).bytes(message.data);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ResponseOther
 */
export const ResponseOther = new ResponseOther$Type();
