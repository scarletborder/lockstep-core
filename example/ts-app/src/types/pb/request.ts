// @generated by protobuf-ts 2.11.1
// @generated from protobuf file "request.proto" (package "messages", syntax proto3)
// tslint:disable
import { Empty } from "./google/protobuf/empty";
import { ServiceType } from "@protobuf-ts/runtime-rpc";
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
// 即时性消息
// http 请求和响应

/**
 * 列出房间的响应消息
 * 包含所有可用房间的ID列表
 *
 * @generated from protobuf message messages.ListRoomsResponse
 */
export interface ListRoomsResponse {
    /**
     * @generated from protobuf field: repeated uint32 rooms = 1
     */
    rooms: number[]; // 房间ID列表，每个ID是一个无符号32位整数
}
/**
 * 创建房间的请求消息
 * 客户端发送此消息来创建一个新的房间
 *
 * @generated from protobuf message messages.CreateRoomRequest
 */
export interface CreateRoomRequest {
    /**
     * @generated from protobuf field: string name = 1
     */
    name: string; // 房间名称，用于标识房间
    /**
     * @generated from protobuf field: string key = 2
     */
    key: string; // 房间密钥，用于房间访问控制
}
/**
 * 创建房间的响应消息
 * 服务器返回新创建房间的ID
 *
 * @generated from protobuf message messages.CreateRoomResponse
 */
export interface CreateRoomResponse {
    /**
     * @generated from protobuf field: uint32 room_id = 1
     */
    roomId: number; // 新创建房间的唯一ID
}
/**
 * 通用错误响应消息
 * 用于在请求失败时返回错误信息
 *
 * @generated from protobuf message messages.ErrorResponse
 */
export interface ErrorResponse {
    /**
     * @generated from protobuf field: string error = 1
     */
    error: string; // 错误描述信息
}
// Deprecated: 使用路径参数传参，并使用原生http请求+upgrade来达到长连接效果
// 通过RPC加入房间的请求消息
// 虽然主要通过查询参数传递，但定义消息以保持一致性
// message JoinRoomRequest {
//   uint32 room_id = 1; // 要加入的房间ID
//   string key = 2;     // 可选的房间密钥，用于验证访问权限
// }

/**
 * 健康检查的响应消息
 * 提供服务器状态和可用端点信息
 *
 * @generated from protobuf message messages.HealthCheckResponse
 */
export interface HealthCheckResponse {
    /**
     * @generated from protobuf field: string status = 1
     */
    status: string; // 服务器状态，通常为"ok"
    /**
     * @generated from protobuf field: string message = 2
     */
    message: string; // 状态消息描述
    /**
     * @generated from protobuf field: repeated uint32 hash = 3
     */
    hash: number[]; // TLS证书的SHA256哈希值，用于验证
}
// @generated message type with reflection information, may provide speed optimized methods
class ListRoomsResponse$Type extends MessageType<ListRoomsResponse> {
    constructor() {
        super("messages.ListRoomsResponse", [
            { no: 1, name: "rooms", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<ListRoomsResponse>): ListRoomsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rooms = [];
        if (value !== undefined)
            reflectionMergePartial<ListRoomsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ListRoomsResponse): ListRoomsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* repeated uint32 rooms */ 1:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.rooms.push(reader.uint32());
                    else
                        message.rooms.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ListRoomsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* repeated uint32 rooms = 1; */
        if (message.rooms.length) {
            writer.tag(1, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.rooms.length; i++)
                writer.uint32(message.rooms[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ListRoomsResponse
 */
export const ListRoomsResponse = new ListRoomsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRoomRequest$Type extends MessageType<CreateRoomRequest> {
    constructor() {
        super("messages.CreateRoomRequest", [
            { no: 1, name: "name", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "key", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<CreateRoomRequest>): CreateRoomRequest {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.name = "";
        message.key = "";
        if (value !== undefined)
            reflectionMergePartial<CreateRoomRequest>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRoomRequest): CreateRoomRequest {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string name */ 1:
                    message.name = reader.string();
                    break;
                case /* string key */ 2:
                    message.key = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRoomRequest, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string name = 1; */
        if (message.name !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.name);
        /* string key = 2; */
        if (message.key !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.key);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.CreateRoomRequest
 */
export const CreateRoomRequest = new CreateRoomRequest$Type();
// @generated message type with reflection information, may provide speed optimized methods
class CreateRoomResponse$Type extends MessageType<CreateRoomResponse> {
    constructor() {
        super("messages.CreateRoomResponse", [
            { no: 1, name: "room_id", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<CreateRoomResponse>): CreateRoomResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.roomId = 0;
        if (value !== undefined)
            reflectionMergePartial<CreateRoomResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: CreateRoomResponse): CreateRoomResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 room_id */ 1:
                    message.roomId = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: CreateRoomResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 room_id = 1; */
        if (message.roomId !== 0)
            writer.tag(1, WireType.Varint).uint32(message.roomId);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.CreateRoomResponse
 */
export const CreateRoomResponse = new CreateRoomResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ErrorResponse$Type extends MessageType<ErrorResponse> {
    constructor() {
        super("messages.ErrorResponse", [
            { no: 1, name: "error", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<ErrorResponse>): ErrorResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.error = "";
        if (value !== undefined)
            reflectionMergePartial<ErrorResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ErrorResponse): ErrorResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string error */ 1:
                    message.error = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ErrorResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string error = 1; */
        if (message.error !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.error);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.ErrorResponse
 */
export const ErrorResponse = new ErrorResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HealthCheckResponse$Type extends MessageType<HealthCheckResponse> {
    constructor() {
        super("messages.HealthCheckResponse", [
            { no: 1, name: "status", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "hash", kind: "scalar", repeat: 1 /*RepeatType.PACKED*/, T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<HealthCheckResponse>): HealthCheckResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.status = "";
        message.message = "";
        message.hash = [];
        if (value !== undefined)
            reflectionMergePartial<HealthCheckResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HealthCheckResponse): HealthCheckResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string status */ 1:
                    message.status = reader.string();
                    break;
                case /* string message */ 2:
                    message.message = reader.string();
                    break;
                case /* repeated uint32 hash */ 3:
                    if (wireType === WireType.LengthDelimited)
                        for (let e = reader.int32() + reader.pos; reader.pos < e;)
                            message.hash.push(reader.uint32());
                    else
                        message.hash.push(reader.uint32());
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HealthCheckResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string status = 1; */
        if (message.status !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.status);
        /* string message = 2; */
        if (message.message !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.message);
        /* repeated uint32 hash = 3; */
        if (message.hash.length) {
            writer.tag(3, WireType.LengthDelimited).fork();
            for (let i = 0; i < message.hash.length; i++)
                writer.uint32(message.hash[i]);
            writer.join();
        }
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message messages.HealthCheckResponse
 */
export const HealthCheckResponse = new HealthCheckResponse$Type();
/**
 * @generated ServiceType for protobuf service messages.LockstepService
 */
export const LockstepService = new ServiceType("messages.LockstepService", [
    { name: "ListRooms", options: {}, I: Empty, O: ListRoomsResponse },
    { name: "CreateRoom", options: {}, I: CreateRoomRequest, O: CreateRoomResponse },
    { name: "HealthCheck", options: {}, I: Empty, O: HealthCheckResponse }
]);
